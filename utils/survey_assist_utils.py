from typing import Optional

from flask import current_app, session
from survey_assist_utils.logging import get_logger

from models.question import Question

logger = get_logger(__name__)


def classify(
    type: str, job_title: str, job_description: str, org_description: str
) -> Optional[dict]:
    """Classify the given parameters using the API client."""
    api_client = current_app.api_client
    response = api_client.post(
        "/survey-assist/classify",
        body={
            "llm": "gemini",
            "type": type,
            "job_title": job_title,
            "job_description": job_description,
            "org_description": org_description,
        },
    )

    if isinstance(response, dict):
        logger.info(f"Successfully classified {type}.")
        return response
    logger.error(f"Failed to classify {type}.")
    return None


def get_next_followup(
    followup_questions: list[dict],
    question_type: str,
) -> tuple[str, dict] | None:
    """Add follow-up questions to the session and return the next one.

    This function stores incoming follow-up questions in the session's "follow_up"
    list, then retrieves the next question based on the specified order.

    Args:
        followup_questions: A list of follow-up question dictionaries to add.
        question_type: Determines how to retrieve the next question.
            - "open": retrieve from the beginning of the list.
            - "closed": retrieve from the end.
            - "both": behave the same as "open".

    Returns:
        A tuple containing the question text and full question dictionary,
        or None if no questions are available or the order is invalid.
    """
    logger.debug(f"Follow-up questions: {followup_questions}")

    if "follow_up" not in session:
        session["follow_up"] = []

    session["follow_up"].extend(followup_questions)
    session.modified = True

    followup_list = session.get("follow_up", [])
    if not followup_list:
        return None

    if question_type in ("open", "both"):
        question_data = followup_list.pop(0)
    elif question_type == "closed":
        question_data = followup_list.pop(-1)
    else:
        logger.warning(f"Invalid question_type: {question_type}")
        return None

    session["follow_up"] = followup_list
    logger.debug(f"Updated follow-up list: {session['follow_up']}")
    session.modified = True

    question_text = question_data.get("question_text", "")
    return question_text, question_data


def format_followup(question_data: dict, question_text: str) -> Question:
    """Formats a follow-up question and stores it in session.

    This function creates a Question object from raw follow-up question data
    and appends it to the session's "follow_up" list.

    Args:
        question_data: A dictionary containing follow-up question fields,
            including 'follow_up_id', 'question_name', 'response_type', and optionally 'select_options'.
        question_text: The main text content of the question to be displayed.

    Returns:
        A Question instance representing the formatted follow-up question.
    """
    response_type = question_data["response_type"]
    response_options = []

    # If the response type is "select", build the options
    if response_type == "select":
        response_options = [
            {
                "id": f"{option}-id",
                "label": {"text": option},
                "value": option,
            }
            for option in question_data.get("select_options", [])
        ]

    formatted_question = Question(
        question_id=question_data["follow_up_id"],
        question_name=question_data["question_name"],
        question_title=question_data["question_name"],
        question_text=question_text,
        question_description="This question is generated by Survey Assist",
        response_type=response_type,
        response_options=response_options,
    )

    logger.debug(f"Formatted question: {formatted_question.to_dict()}")
    return formatted_question
